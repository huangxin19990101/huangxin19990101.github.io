<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.hxcloud.xyz","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础1:数据库字符串比较不区分大小写    1where name &#x3D; &#39;Whistler&#39;  &#x3D;&#x3D;&#x3D; where name &#x3D; &#39;WHIstler&#39;  2: 去重 distinct 1select distinct name from pet;  3:排序 根据多个字段进行排序,先按第一个字段排序,重复的会变成类似一个组,接着在组里按第二个字段排序 1select * from pet orde">
<meta property="og:type" content="website">
<meta property="og:title" content="Kay&#39;s Blog">
<meta property="og:url" content="blog.hxcloud.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93.html">
<meta property="og:site_name" content="Kay&#39;s Blog">
<meta property="og:description" content="基础1:数据库字符串比较不区分大小写    1where name &#x3D; &#39;Whistler&#39;  &#x3D;&#x3D;&#x3D; where name &#x3D; &#39;WHIstler&#39;  2: 去重 distinct 1select distinct name from pet;  3:排序 根据多个字段进行排序,先按第一个字段排序,重复的会变成类似一个组,接着在组里按第二个字段排序 1select * from pet orde">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567607649519.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567778913252.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567778933750.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567900526580.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567900564609.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567901087591.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568032945433.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568033531663.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568033636330.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568036003228.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568037975680.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039206617.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039250838.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039294138.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039320343.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039344732.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039362207.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039373326.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039431705.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039441620.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039459437.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568039473410.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568432312261.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568432131167.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568082453848.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568432490957.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568432529540.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568536924180.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568541699154.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568541731290.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542007707.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542239093.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542126173.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542145192.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542275731.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568542346600.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568083780077.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568084220432.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568085322194.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568117641335.png">
<meta property="og:image" content="c:%5CUsers%5C18439%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568120169130.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568120683246.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568120796523.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568121559494.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568429309734.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568429938777.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568430048109.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568430185003.png">
<meta property="og:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1568431175949.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image015.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image017.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image025.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image027.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image029.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image031.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image039.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image041.jpg">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image043.jpg">
<meta property="og:image" content="blog.hxcloud.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93.assets/1573127667288.png">
<meta property="og:image" content="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png">
<meta property="article:published_time" content="2020-04-03T12:51:34.324Z">
<meta property="article:modified_time" content="2019-11-10T12:28:15.895Z">
<meta property="article:author" content="Kay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="blog.hxcloud.xyz/.%5Ctypora-user-images%5C1567607649519.png">

<link rel="canonical" href="blog.hxcloud.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title> | Kay's Blog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kay's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Record my knowledge</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1:数据库字符串比较不区分大小写   </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where name = 'Whistler'  === where name = 'WHIstler'</span><br></pre></td></tr></table></figure>

<p>2: 去重</p>
<p>distinct</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">name</span> <span class="keyword">from</span> pet;</span><br></pre></td></tr></table></figure>

<p>3:排序</p>
<p>根据多个字段进行排序,先按第一个字段排序,重复的会变成类似一个组,接着在组里按第二个字段排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pet <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>, sex <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>4:日期计算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">curdate</span>(); //获取当前日期 2019-1-1</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(); //获取当前日期时间 2019-1-1  00:00:01</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">YEAR</span>(<span class="string">'2018‐02‐05'</span>) <span class="keyword">AS</span> <span class="keyword">YEARS</span>  //获取当前的年  <span class="number">2018</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">'2018‐02‐05'</span>) <span class="keyword">AS</span> <span class="keyword">MONTH</span>  //获取当前的月 <span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">'2018‐02‐05'</span>) <span class="keyword">DAy</span> //获取当前的日 <span class="number">5</span></span><br><span class="line">//比较日期函数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birth, <span class="keyword">CURDATE</span>(), </span><br><span class="line">//常量值为 <span class="keyword">DAY</span>,<span class="keyword">HOUR</span>,<span class="keyword">MINUTE</span>,<span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, <span class="string">'2018-03-20 23:59:00'</span>, <span class="string">'2019-03-22 00:00:00'</span>) <span class="keyword">AS</span> age</span><br></pre></td></tr></table></figure>

<p>5:详情</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desc shop;//查看表结构</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> shop;//查看建表语句</span><br></pre></td></tr></table></figure>

<p>6:查询最大值的某条数据<br><img src=".%5Ctypora-user-images%5C1567607649519.png" alt="1567607649519"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.*</span><br><span class="line"><span class="keyword">from</span> shop s1</span><br><span class="line">       <span class="keyword">left</span> <span class="keyword">join</span> shop s2 <span class="keyword">on</span> s1.price &lt; s2.price</span><br><span class="line"><span class="keyword">where</span> s2.article <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这条sql可以查出最大值的那条记录</p>
<p>left join已左表为主</p>
<p>s1已经查出所有记录, on s1.price &lt; s2.price 关联s2表,这样左表与右表关联的记录则是所有小于最大值的记录,再通过右表的条件过滤右表数据为不存在,这样左表中与右表有关联的数据则全部过滤掉,结果就是查出了最大值的记录</p>
<p>注意,必须left join才能查出</p>
<p><img src=".%5Ctypora-user-images%5C1567778913252.png" alt="1567778913252"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,<span class="keyword">max</span>(price) <span class="keyword">from</span>  shop <span class="keyword">group</span> <span class="keyword">by</span> article;</span><br></pre></td></tr></table></figure>

<p><img src=".%5Ctypora-user-images%5C1567778933750.png" alt="1567778933750"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.* <span class="keyword">from</span> shop s1 <span class="keyword">where</span> price = (<span class="keyword">select</span> <span class="keyword">max</span>(price) <span class="keyword">from</span> shop s2 <span class="keyword">where</span> s1.article = s2.article);</span><br></pre></td></tr></table></figure>

<p>上面两条sql的效果一样, 第二条主要是通过子查询查出同样acticle的数据,取出最大的那条.</p>
<p>获取某个区间价格的总和</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.*,<span class="keyword">sum</span>(s1.price) <span class="keyword">from</span> shop s1 <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> shop s2 <span class="keyword">where</span> s1.article= s2.article <span class="keyword">and</span> s2.price &gt; <span class="number">2</span> );</span><br></pre></td></tr></table></figure>

<p>通过子查询即可解决.</p>
<h5 id="1-sql分类"><a href="#1-sql分类" class="headerlink" title="1.sql分类"></a>1.sql分类</h5><ol>
<li><p>DDL:<br>数据定义语言: </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceeate table;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DML<br>数据操纵语言</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> ,<span class="keyword">insert</span> ,<span class="keyword">delete</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DCL<br>数据控制语言<br>设置用户权限和控制事务语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span>,<span class="keyword">if</span> ..else,<span class="keyword">while</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="mysql备份"><a href="#mysql备份" class="headerlink" title="mysql备份"></a>mysql备份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//mysql 备份    第一个参数为数据库&gt;后面为路径</span><br><span class="line">mysqldump -u root -p menagerie&gt;G:\sql\managerie.sql</span><br><span class="line">//mysql 恢复    第一个参数为数据库&lt;后面为路径</span><br><span class="line">mysql -uroot -p mysqldumptest&lt;G:\sql\managerie.sql</span><br><span class="line"></span><br><span class="line">注意箭头方向不同</span><br></pre></td></tr></table></figure>

<h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b;</span><br><span class="line">结果等 a的行数*b的行数;</span><br></pre></td></tr></table></figure>

<p>IN 和 notIn</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id in(1,2,3) = id=1 or id=2 or id=3</span><br><span class="line">id not in(1,2,3) = id!=1 and id!=2 and id!=3</span><br></pre></td></tr></table></figure>

<p>exists 和 not exists</p>
<h5 id="UNION-和-UNION-ALL"><a href="#UNION-和-UNION-ALL" class="headerlink" title="UNION 和 UNION ALL"></a>UNION 和 UNION ALL</h5><p>用于将不同表中相同列的数据查询出来<br>union(不包含重复数据)</p>
<p><img src=".%5Ctypora-user-images%5C1567900526580.png" alt="1567900526580"></p>
<p>union all(包含重复数据)</p>
<p><img src=".%5Ctypora-user-images%5C1567900564609.png" alt="1567900564609"></p>
<h5 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> sex  <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">then</span> <span class="string">'女'</span>  <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">'男'</span>  <span class="keyword">end</span>  <span class="keyword">as</span> sex ,pet.*<span class="keyword">from</span> pet;</span><br></pre></td></tr></table></figure>

<p><img src=".%5Ctypora-user-images%5C1567901087591.png" alt="1567901087591"></p>
<h3 id="MYSQL编码"><a href="#MYSQL编码" class="headerlink" title="MYSQL编码"></a>MYSQL编码</h3><p>UTF-8: 一个汉字=3个字节<br>GBK:一个汉字=2个字节</p>
<p>float:8位精度 ,4字节<br>double:16位精度,8字节</p>
<p>decimal:定点数 ,浮点数存的是近似值,定点数存放的是精确值<br>decimal(m,d)  m总位数, d小数位</p>
<p><img src=".%5Ctypora-user-images%5C1568032945433.png" alt="1568032945433"></p>
<p><img src=".%5Ctypora-user-images%5C1568033531663.png" alt="1568033531663"></p>
<p><img src=".%5Ctypora-user-images%5C1568033636330.png" alt="1568033636330"></p>
<p>&lt;=&gt;运算符</p>
<p>a=null<br>where a = null  结果 false<br>where a &lt;=&gt; null 结果 true</p>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>三种</p>
<p><img src=".%5Ctypora-user-images%5C1568036003228.png" alt="1568036003228"></p>
<p><img src=".%5Ctypora-user-images%5C1568037975680.png" alt="1568037975680"></p>
<h4 id="修改表数据"><a href="#修改表数据" class="headerlink" title="修改表数据"></a>修改表数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aaa </span><br><span class="line"><span class="keyword">change</span> a b 修改</span><br><span class="line"><span class="keyword">add</span> a  添加</span><br><span class="line"><span class="keyword">modify</span> a 修改</span><br><span class="line"><span class="keyword">drop</span>  a 删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> a <span class="keyword">rename</span> b;</span><br></pre></td></tr></table></figure>

<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src=".%5Ctypora-user-images%5C1568039206617.png" alt="1568039206617"></p>
<p><img src=".%5Ctypora-user-images%5C1568039250838.png" alt="1568039250838"></p>
<p><img src=".%5Ctypora-user-images%5C1568039294138.png" alt="1568039294138"></p>
<p><img src=".%5Ctypora-user-images%5C1568039320343.png" alt="1568039320343"></p>
<p><img src=".%5Ctypora-user-images%5C1568039344732.png" alt="1568039344732"></p>
<p><img src=".%5Ctypora-user-images%5C1568039362207.png" alt="1568039362207"></p>
<p><img src=".%5Ctypora-user-images%5C1568039373326.png" alt="1568039373326"></p>
<p><img src=".%5Ctypora-user-images%5C1568039431705.png" alt="1568039431705"></p>
<p><img src=".%5Ctypora-user-images%5C1568039441620.png" alt="1568039441620"></p>
<p><img src=".%5Ctypora-user-images%5C1568039459437.png" alt="1568039459437"></p>
<p><img src=".%5Ctypora-user-images%5C1568039473410.png" alt="1568039473410"></p>
<h3 id="MYSQL索引"><a href="#MYSQL索引" class="headerlink" title="MYSQL索引"></a>MYSQL索引</h3><p>单列索引:一个索引只有一个列<br>组合索引:一个索引包含多个列<br>创建索引时,一般要确保索引是应用在sql查询语句的条件 (where 后面)<br>索引也是一张表,该表保存了主键和索引字段,并指向实体表的记录<br>过多的使用索引也会造成滥用,索引可以提升查询的速度,但是也会降低表更新的速度(insert,update,delete),因为更新的时候不止要关系表,还要更新索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//创建索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名集合)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> article_index <span class="keyword">on</span> shop(article);</span><br><span class="line">//修改表的时候创建</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">index</span> 索引名(列名集合);</span><br><span class="line">//创建表的时候创建索引</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`shop`</span> (</span><br><span class="line">  <span class="string">`article`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> zerofill <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000'</span>,</span><br><span class="line">  <span class="string">`dealer`</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="keyword">double</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`article`</span>,<span class="string">`dealer`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`article_index`</span> (<span class="string">`article`</span>)</span><br><span class="line">)</span><br><span class="line">//删除索引</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> [索引名] <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//唯一索引,索引列的值必须唯一,允许<span class="literal">null</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名集合)</span><br><span class="line">区别在于加了一个<span class="keyword">unique</span>关键字</span><br><span class="line"></span><br><span class="line">//主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span>(列名集合);</span><br><span class="line">主键必须not null, unique;</span><br><span class="line"></span><br><span class="line">//显示索引信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure>

<p><img src=".%5Ctypora-user-images%5C1568432312261.png" alt="1568432312261"></p>
<p><img src=".%5Ctypora-user-images%5C1568432131167.png" alt="1568432131167"></p>
<p><img src=".%5Ctypora-user-images%5C1568082453848.png" alt="1568082453848"></p>
<p><img src=".%5Ctypora-user-images%5C1568432490957.png" alt="1568432490957"></p>
<p><img src=".%5Ctypora-user-images%5C1568432529540.png" alt="1568432529540"></p>
<h4 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h4><p>索引不止会影响insert,update,delete的效率,也有可能会影响查询的效率,如果索引过多,分析应该使用哪个索引的速度就越慢,有时候需要删除不需要的索引</p>
<p>删除重复,冗余的索引,</p>
<p><img src=".%5Ctypora-user-images%5C1568536924180.png" alt="1568536924180"></p>
<p>对于innerdb来说,每一个索引后面实际都会包含主键,这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</p>
<p>3、如何查找重复索引</p>
<p>工具：使用pt-duplicate-key-checker工具检查重复及冗余索引</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p>
<p>4、索引维护的方法</p>
<p>​       由于业务变更，某些索引是后续不需要使用的，就要进行删除。</p>
<p>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；</p>
<p>附：<a href="https://www.percona.com/downloads/" target="_blank" rel="noopener">https://www.percona.com/downloads/</a></p>
<p> <img src=".%5Ctypora-user-images%5C1568541699154.png" alt="1568541699154"></p>
<p><img src=".%5Ctypora-user-images%5C1568541731290.png" alt="1568541731290"></p>
<p><img src=".%5Ctypora-user-images%5C1568542007707.png" alt="1568542007707"></p>
<p><img src=".%5Ctypora-user-images%5C1568542239093.png" alt="1568542239093"></p>
<p><img src=".%5Ctypora-user-images%5C1568542126173.png" alt="1568542126173"></p>
<p><img src=".%5Ctypora-user-images%5C1568542145192.png" alt="1568542145192"></p>
<p>列上进行运算索引无法命中</p>
<p><img src=".%5Ctypora-user-images%5C1568542275731.png" alt="1568542275731"></p>
<p><img src=".%5Ctypora-user-images%5C1568542346600.png" alt="1568542346600"></p>
<h1 id="MYSQL事务"><a href="#MYSQL事务" class="headerlink" title="MYSQL事务"></a>MYSQL事务</h1><p>一致性,隔离性,原子性,持久性</p>
<p><img src=".%5Ctypora-user-images%5C1568083780077.png" alt="1568083780077"></p>
<p><img src=".%5Ctypora-user-images%5C1568084220432.png" alt="1568084220432"></p>
<p><img src=".%5Ctypora-user-images%5C1568085322194.png" alt="1568085322194"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<h1 id="MYSQL优化"><a href="#MYSQL优化" class="headerlink" title="MYSQL优化"></a>MYSQL优化</h1><p>开启慢查日志</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//查询慢查日志是否开启</span><br><span class="line">mysql&gt; show variables like 'slow_query_log';</span><br><span class="line">+<span class="comment">----------------+-------+</span></span><br><span class="line">| Variable_name  | Value |</span><br><span class="line">+<span class="comment">----------------+-------+</span></span><br><span class="line">| slow_query_log | ON    |</span><br><span class="line">+<span class="comment">----------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">//开启慢查询日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_queries_not_using_indexes=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查询sql超时记录时间</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br><span class="line">//大于1秒钟的数据记录到慢日志中，如果设置为默认0，则会有大量的信息存储在磁盘中，磁盘很容易满掉</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>mysqldumpslow.pl<br>慢查询日志分析工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl mysqldumpslow.pl -t 10  DESKTOP-R8PJASH-slow.log</span><br></pre></td></tr></table></figure>

<h1 id="三种需要优化的sql"><a href="#三种需要优化的sql" class="headerlink" title="三种需要优化的sql"></a>三种需要优化的sql</h1><p>查询次数多且占用时间长的sql<br>IO大的sql<br>未命中索引的sql</p>
<p>查看sql的执行计划</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staff;</span><br></pre></td></tr></table></figure>

<p><img src=".%5Ctypora-user-images%5C1568117641335.png" alt="1568117641335"></p>
<h2 id="每个字段的说明："><a href="#每个字段的说明：" class="headerlink" title="每个字段的说明："></a>每个字段的说明：</h2><p>1）、id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表示 这是一个结果集，不需要使用它来进行查询。</p>
<p>2）、select_type列常见的有：</p>
<p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p>
<p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p>
<p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p>
<p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p>
<p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p>
<p>F：subquery：除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery</p>
<p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p>
<p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p>
<p>3）、table</p>
<p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived N>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&lt;union M,N&gt;，与<derived N>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</p>
<p>4）、type</p>
<p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p>
<p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p>
<p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p>
<p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p>
<p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p>
<p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
<p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p>
<p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p>
<p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p>
<p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p>
<p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p>
<p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p>
<p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p>
<p>5）、possible_keys</p>
<p>查询可能使用到的索引都会在这里列出来</p>
<p>6）、key</p>
<p>查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</p>
<p>7）、key_len</p>
<p>用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。</p>
<p>8）、ref</p>
<p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p>
<p>9）、rows</p>
<p>这里是执行计划中估算的扫描行数，不是精确值</p>
<p>10）、extra</p>
<p>这个列可以显示的信息非常多，有几十种，常用的有</p>
<p>A：distinct：在select部分使用了distinc关键字</p>
<p>B：no tables used：不带from字句的查询或者From dual查询</p>
<p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p>
<p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p>
<p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p>
<p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p>
<p>G：using sort_union，using_union，using intersect，using sort_intersection：</p>
<p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p>
<p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p>
<p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p>
<p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p>
<p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p>
<p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p>
<p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p>
<p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p>
<p>11）、filtered</p>
<p>使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</p>
<p><img src="C:%5CUsers%5C18439%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568120169130.png" alt="1568120169130"></p>
<h3 id="max函数优化"><a href="#max函数优化" class="headerlink" title="max函数优化"></a>max函数优化</h3><p>可以发现扫描了全表</p>
<p><img src=".%5Ctypora-user-images%5C1568120683246.png" alt="1568120683246"></p>
<p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_payment_date <span class="keyword">on</span> payment(payment_date);</span><br></pre></td></tr></table></figure>

<p><img src=".%5Ctypora-user-images%5C1568120796523.png" alt="1568120796523"></p>
<p>索引是顺序操作的，不需要扫描表，执行效率就会比较恒定，</p>
<h3 id="COUNT函数优化"><a href="#COUNT函数优化" class="headerlink" title="COUNT函数优化"></a>COUNT函数优化</h3><p><img src=".%5Ctypora-user-images%5C1568121559494.png" alt="1568121559494"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(release_year=<span class="string">'2006'</span> <span class="keyword">or</span> <span class="literal">null</span>) <span class="keyword">as</span> <span class="string">'06films'</span>,<span class="keyword">count</span>(release_year=<span class="string">'2007'</span> <span class="keyword">or</span> <span class="literal">null</span>) <span class="keyword">as</span> <span class="string">'07films'</span> <span class="keyword">from</span> film;</span><br><span class="line"></span><br><span class="line">输入数值=2006,count+1 ,否则为null,不计入count</span><br><span class="line">count(release_year='2006' or null)</span><br></pre></td></tr></table></figure>

<p>查询两个count的正确查询方法</p>
<p>count(id)不包含null,count(*)包含null</p>
<h4 id="子查询最好把in优化成inner-join查询-但是join查询会产生重复数据-可以使用distinct去重-join的查询效率更高"><a href="#子查询最好把in优化成inner-join查询-但是join查询会产生重复数据-可以使用distinct去重-join的查询效率更高" class="headerlink" title="子查询最好把in优化成inner join查询 , 但是join查询会产生重复数据,可以使用distinct去重,join的查询效率更高"></a>子查询最好把in优化成inner join查询 , 但是join查询会产生重复数据,可以使用distinct去重,join的查询效率更高</h4><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>分页分为逻辑分页和物理分页<br>逻辑分页就为普通的limit分页,物理分页则是一次查出所有在内存里进行list.subList()分页</p>
<h4 id="group分组优化"><a href="#group分组优化" class="headerlink" title="group分组优化"></a>group分组优化</h4><p><img src=".%5Ctypora-user-images%5C1568429309734.png" alt="1568429309734"></p>
<p>说明：从上面的执行计划来看，这种优化后的方式没有使用临时文件和文件排序的方式了，取而代之的是使用了索引。查询效率老高了。</p>
<p>多表分组最好在inner join的第二个表里进行分组,而不是两个表相关联后进行分组,从执行计划看来效率更高</p>
<p>夺标关联的时候可以使用using(字段名)代替 on , 前提是两个表关联的字段名必须相同</p>
<h4 id="limit查询优化"><a href="#limit查询优化" class="headerlink" title="limit查询优化"></a>limit查询优化</h4><p>Limit常用于分页处理，时长会伴随order by从句使用，因此大多时候回使用Filesorts这样会造成大量的IO问题。</p>
<p>例子：</p>
<p>​       需求：查询影片id和描述信息，并根据主题进行排序，取出从序号50条开始的5条数据。</p>
<p><img src=".%5Ctypora-user-images%5C1568429938777.png" alt="1568429938777"></p>
<p>上面的使用了文件排序 ,尽量让sql使用索引而不是文件排序</p>
<p><img src=".%5Ctypora-user-images%5C1568430048109.png" alt="1568430048109"></p>
<p>上面的sql使用了主键进行排序,避免了使用文件排序,效率更高 </p>
<p><img src=".%5Ctypora-user-images%5C1568430185003.png" alt="1568430185003"></p>
<p>从上面可以看到,分页越往后面扫描的操作会越来越大(已经扫描了1000条),需要进一步的优化</p>
<p>优化步骤    记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</p>
<p>​    <img src=".%5Ctypora-user-images%5C1568431175949.png" alt="1568431175949"></p>
<p>可以看到使用主键过滤后即使从一千条开始也只扫描了5条,并且只用到了where,效率更高,这种方法的前提是主键顺序不能出错<br>主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足5行的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可.</p>
<h1 id="一、MYSQL数据库设计规范"><a href="#一、MYSQL数据库设计规范" class="headerlink" title="一、MYSQL数据库设计规范"></a>一、MYSQL数据库设计规范</h1><h2 id="1、-数据库命名规范"><a href="#1、-数据库命名规范" class="headerlink" title="1、 数据库命名规范"></a>1、 数据库命名规范</h2><p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;</p>
<p>b、命名简洁明确(长度不能超过30个字符);</p>
<p>c、例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;</p>
<p>d、 除非是备份数据库可以加0-9的自然数：user_db_20151210;</p>
<h2 id="2、-数据库表名命名规范"><a href="#2、-数据库表名命名规范" class="headerlink" title="2、 数据库表名命名规范"></a>2、 数据库表名命名规范</h2><p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;</p>
<p>​    b、命名简洁明确,多个单词用下划线’_’分隔;</p>
<p>​    例如：user_login, user_profile, user_detail, user_role, user_role_relation,</p>
<p>​            user_role_right, user_role_right_relation</p>
<p>注：表前缀’user_’可以有效的把相同关系的表显示在一起;</p>
<h2 id="3、-数据库表字段名命名规范"><a href="#3、-数据库表字段名命名规范" class="headerlink" title="3、 数据库表字段名命名规范"></a>3、 数据库表字段名命名规范</h2><p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;</p>
<p>​    b、命名简洁明确,多个单词用下划线’_’分隔;</p>
<p>​        例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;</p>
<p>​    c、每个表中必须有自增主键,add_time(默认系统时间)</p>
<p>d、表与表之间的相关联字段名称要求尽可能的相同;</p>
<h2 id="4、-数据库表字段类型规范"><a href="#4、-数据库表字段类型规范" class="headerlink" title="4、 数据库表字段类型规范"></a>4、 数据库表字段类型规范</h2><p>用尽量少的存储空间来存数一个字段的数据;</p>
<p>例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</p>
<p>IP地址最好使用int类型;</p>
<p>固定长度的类型最好使用char,例如：邮编;</p>
<p>能使用tinyint就不要使用smallint,int;</p>
<p>最好给每个字段一个默认值,最好不能为null;</p>
<h2 id="5、-数据库表索引规范"><a href="#5、-数据库表索引规范" class="headerlink" title="5、 数据库表索引规范"></a>5、 数据库表索引规范</h2><p>命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;</p>
<p>为每个表创建一个主键索引;</p>
<p>为每个表创建合理的索引;</p>
<p>建立复合索引请慎重;</p>
<h2 id="6、-简单熟悉数据库范式"><a href="#6、-简单熟悉数据库范式" class="headerlink" title="6、 简单熟悉数据库范式"></a>6、 简单熟悉数据库范式</h2><p>1、第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);</p>
<p>​      例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</p>
<p>​         </p>
<p>2、第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;</p>
<p>​            备注：必须先满足第一范式;</p>
<p>3、第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;</p>
<p>备注：必须先满足第二范式;</p>
<p>​      备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</p>
<p>​    例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</p>
<h1 id="一、MYSQL数据库设计原则"><a href="#一、MYSQL数据库设计原则" class="headerlink" title="一、MYSQL数据库设计原则"></a>一、MYSQL数据库设计原则</h1><h2 id="1、核心原则"><a href="#1、核心原则" class="headerlink" title="1、核心原则"></a>1、核心原则</h2><p>不在数据库做运算;</p>
<p>cpu计算务必移至业务层;</p>
<p>控制列数量(字段少而精,字段数建议在20以内);</p>
<p>平衡范式与冗余(效率优先；往往牺牲范式)</p>
<p>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); </p>
<h2 id="2、字段类原则"><a href="#2、字段类原则" class="headerlink" title="2、字段类原则"></a>2、字段类原则</h2><p>用好数值类型(用合适的字段类型节约空间);</p>
<p>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</p>
<p>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</p>
<p>少用text类型(尽量使用varchar代替text字段); </p>
<h2 id="3、索引类原则"><a href="#3、索引类原则" class="headerlink" title="3、索引类原则"></a>3、索引类原则</h2><p>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</p>
<p>字符字段必须建前缀索引;</p>
<p>不在索引做列运算;</p>
<p>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</p>
<p>不用外键(由程序保证约束);</p>
<h2 id="4、sql类原则"><a href="#4、sql类原则" class="headerlink" title="4、sql类原则"></a>4、sql类原则</h2><p>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</p>
<p>简单的事务;</p>
<p>避免使用trig/func(触发器、函数不用客户端程序取而代之);</p>
<p>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</p>
<p>OR改写为IN(or的效率是n级别);</p>
<p> OR改写为UNION(mysql的索引合并很弱智);</p>
<p>select id from t where phone = ’159′ or name = ‘john’;</p>
<p>=&gt;</p>
<p>select id from t where phone=’159′</p>
<p>union</p>
<p>select id from t where name=’jonh’</p>
<p>​        避免负向%;</p>
<p>​        慎用count(*);</p>
<p>​        limit高效分页(limit越大，效率越低);</p>
<p>​        使用union all替代union(union有去重开销);</p>
<p>​        少用连接join;</p>
<p>​        使用group by;</p>
<p>​        请使用同类型比较;</p>
<p>​        打散批量更新;</p>
<h1 id="数据库结构的优化"><a href="#数据库结构的优化" class="headerlink" title="数据库结构的优化"></a>数据库结构的优化</h1><h2 id="1、选择合适的数据类型"><a href="#1、选择合适的数据类型" class="headerlink" title="1、选择合适的数据类型"></a>1、选择合适的数据类型</h2><h3 id="1、数据类型选择"><a href="#1、数据类型选择" class="headerlink" title="1、数据类型选择"></a>1、数据类型选择</h3><p>​       数据类型的选择，重点在于“合适”二字，如何确定选择的数据类型是否合适了？</p>
<p>1、 使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</p>
<p>2、 使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</p>
<p>3、 尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</p>
<p>4、 尽量少用text类型，非用不可时最好考虑分表。</p>
<h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><p>​       <strong>案例一</strong>：int类型存储时间-时间转换</p>
<p>​              使用int来存储日期时间，利用FROM_UNIXTIME(),UNIX_TIMESTAMP()两个函数来进行转换。</p>
<p>创建表：</p>
<p>导入数据：</p>
<p>查询数据：如下图所示：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p>
<p>时间进行转换：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="img"></p>
<p>结论：</p>
<p>1、unix_timestamp()函数是将日期格式的数据转换为int类型</p>
<p>2、FROM_UNIXTIME(timestr)函数是将int类型转换为时间格式</p>
<p>案例二：ip地址的存储</p>
<p>在我们的外部应用中，都要记录ip地址，大部分场合都是varchar（15）进行存储，就需要15个字节进行存储，但是bigint只需要8个字节进行存储，当数据量很大的时候（千万级别的数据），相差7个字节，但是不能小看这7个字节，给大家算一下。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img"></p>
<p>一个字段就多这么多，那如果我们这样的字段需要上万个字段了？是需要很多的存储空间的。</p>
<p>使用bigint（8）来存储ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换。</p>
<p>创建表：</p>
<p>导入数据：</p>
<p>转换：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg" alt="img"></p>
<p>检索:</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="img"></p>
<h2 id="2、数据库表的范式化优化"><a href="#2、数据库表的范式化优化" class="headerlink" title="2、数据库表的范式化优化"></a>2、数据库表的范式化优化</h2><h3 id="1、表范式化"><a href="#1、表范式化" class="headerlink" title="1、表范式化"></a>1、表范式化</h3><p>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg" alt="img"></p>
<p>存在以下传递函数依赖关系：</p>
<p>（商品名称）-&gt;（分类）-&gt;（分类描述）</p>
<p>也就是说存在非关键字段 “分类描述”对关键字段“商品名称”的传递函数依赖。</p>
<p>不符合第三范式要求的表存在以下问题：</p>
<p>1、 数据冗余：（分类，分类描述）对于每一个商品都会进行记录。</p>
<p>2、 数据的插入异常</p>
<p>3、 数据的更新异常</p>
<p>4、 数据的删除异常（删除所有数据，分类和分类描述都会删除，没有所有的记录）</p>
<p>如何转换成符合第三范式的表（拆分表）：</p>
<p>将原来的不符合第三范式的表拆分为3个表</p>
<p>商品表、分类表、分类和商品的关系表</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png" alt="img"></p>
<h3 id="2、反范式化"><a href="#2、反范式化" class="headerlink" title="2、反范式化"></a>2、反范式化</h3><p>反范式化是指为了查询效率的考虑把原本符合第三范式的表“适当”的增加冗余，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image015.png" alt="img"></p>
<p>如何查询订单信息？</p>
<p>对于这样的表结构，对于sum（），group by会产生临时表，增加IO量。我们怎么优化都效率不高，那我们怎么样才能让它效率高了，就需要一些字段进行冗余。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image017.png" alt="img"></p>
<p>订单表中增加了冗余字段，那SQL该怎么写了？</p>
<p>说明：表结构的设计直接涉及到SQL的查询效率及优化。</p>
<h2 id="3、数据库表的垂直拆分"><a href="#3、数据库表的垂直拆分" class="headerlink" title="3、数据库表的垂直拆分"></a>3、数据库表的垂直拆分</h2><h3 id="1、垂直拆分定义"><a href="#1、垂直拆分定义" class="headerlink" title="1、垂直拆分定义"></a>1、垂直拆分定义</h3><p>​       所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p>
<h3 id="2、垂直拆分原则"><a href="#2、垂直拆分原则" class="headerlink" title="2、垂直拆分原则"></a>2、垂直拆分原则</h3><p>通常垂直拆分可以按以下原则进行：</p>
<p>1、 把不常用的字段表单独存放到一个表中。</p>
<p>2、 把大字段独立存放到一个表中。</p>
<p>3、 把经常一起使用的字段放到一起。</p>
<p>例子：以film表为例</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png" alt="img"></p>
<p>在该表中，title和description这两个字段占空间比较大，况且在使用频率也比较低，因此可以将其提取出来，将上面的一个达标垂直拆分为两个表（film和film_ext）：如下所示：</p>
<p>1、</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png" alt="img"></p>
<p>2、</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png" alt="img"></p>
<h2 id="4、数据库表的水平拆分"><a href="#4、数据库表的水平拆分" class="headerlink" title="4、数据库表的水平拆分"></a>4、数据库表的水平拆分</h2><h3 id="1、为什么水平拆分"><a href="#1、为什么水平拆分" class="headerlink" title="1、为什么水平拆分"></a>1、为什么水平拆分</h3><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的，以下面的peyment表为例来说明</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image025.jpg" alt="img"></p>
<h3 id="2、水平不拆分原因"><a href="#2、水平不拆分原因" class="headerlink" title="2、水平不拆分原因"></a>2、水平不拆分原因</h3><p>​       如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</p>
<h3 id="3、如何将数据平均分为N份"><a href="#3、如何将数据平均分为N份" class="headerlink" title="3、如何将数据平均分为N份"></a>3、如何将数据平均分为N份</h3><p>​       通常水平拆分的方法为：</p>
<p>1、 对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</p>
<p>2、 针对不动的hashid把数据存储到不同的表中。</p>
<h3 id="4、水平拆分面临的挑战"><a href="#4、水平拆分面临的挑战" class="headerlink" title="4、水平拆分面临的挑战"></a>4、水平拆分面临的挑战</h3><p>1、 夸分区表进行数据查询</p>
<p>前端业务统计：</p>
<p>业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</p>
<p>2、 统计及后台报表操作</p>
<p>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</p>
<h1 id="四、数据库系统配置优化"><a href="#四、数据库系统配置优化" class="headerlink" title="四、数据库系统配置优化"></a>四、数据库系统配置优化</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>数据库是基于操作系统的，目前大多数MySQL都是安装在linux系统之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能，下面就列出一些常用的系统配置。</p>
<h2 id="2、优化配置参数-操作系统"><a href="#2、优化配置参数-操作系统" class="headerlink" title="2、优化配置参数-操作系统"></a>2、优化配置参数-操作系统</h2><p>优化包括操作系统的优化及MySQL的优化</p>
<h3 id="1、操作系统的优化"><a href="#1、操作系统的优化" class="headerlink" title="1、操作系统的优化"></a>1、操作系统的优化</h3><p>网络方面的配置，要修改/etc/sysctl.conf</p>
<p>1、 增加tcp支持的队列数</p>
<p>net.ipv4.tcp_max_syn_backlog = 65535//</p>
<p>2、 减少断开连接时，资源回收(tcp有连接状态)</p>
<p>net.ipv4.tcp_max_tw_buckets = 8000 //</p>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>net.ipv4.tcp_tw_recycle = 1</p>
<p>net.ipv4.tcp_fin_timeout = 10</p>
<p>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</p>
<h3 id="2、打开文件数的限制"><a href="#2、打开文件数的限制" class="headerlink" title="2、打开文件数的限制"></a>2、打开文件数的限制</h3><p>​       打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改/etc/security/limits.conf文件，增加以下内容以修改打开文件数量的限制（永久生效）</p>
<p>如果一次有效，就要使用ulimit –n 65535即可。（默认情况是1024）</p>
<p>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件。</p>
<h2 id="3、优化配置参数-MySQL配置文件优化"><a href="#3、优化配置参数-MySQL配置文件优化" class="headerlink" title="3、优化配置参数- MySQL配置文件优化"></a>3、优化配置参数- MySQL配置文件优化</h2><h3 id="1、MySQL配置文件修改"><a href="#1、MySQL配置文件修改" class="headerlink" title="1、MySQL配置文件修改"></a>1、MySQL配置文件修改</h3><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于/etc/my.cnf 或者是 /etc/mysql/my.cnf在Windows系统配置文件可以是位于C://windows//my.ini文件，MySQL查找配置文件的顺序可以通过以下方法获得。</p>
<p>执行后的结果如下图所示：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image027.jpg" alt="img"></p>
<p>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</p>
<h3 id="2、MySQL配置文件-常用参数说明"><a href="#2、MySQL配置文件-常用参数说明" class="headerlink" title="2、MySQL配置文件-常用参数说明"></a>2、MySQL配置文件-常用参数说明</h3><h4 id="1、连接请求的变量"><a href="#1、连接请求的变量" class="headerlink" title="1、连接请求的变量"></a>1、连接请求的变量</h4><h5 id="1、max-connections"><a href="#1、max-connections" class="headerlink" title="1、max_connections"></a>1、max_connections</h5><p>MySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。</p>
<p>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</p>
<p>show variables like ‘max_connections’ 最大连接数</p>
<p>show status like ‘max_used_connections’响应的连接数</p>
<p>如下：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image029.jpg" alt="img"></p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image031.jpg" alt="img"></p>
<p>说明：理想值设置为多大才合适了？</p>
<p>max_used_connections / max_connections * 100% （理想值≈ 85%）</p>
<p>如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。</p>
<h5 id="2、back-log"><a href="#2、back-log" class="headerlink" title="2、back_log"></a>2、back_log</h5><p>MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</p>
<p>back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。</p>
<p>当观察你主机进程列表（mysql&gt; show full processlist），发现大量264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。</p>
<p>默认数值是50，可调优为128，对于Linux系统设置范围为小于512的整数。</p>
<p>mysql&gt; show full processlist;</p>
<p>+—-+——+———–+——–+———+——+——-+———————–+</p>
<p>| Id | User | Host      | db     | Command | Time | State | Info                  |</p>
<p>+—-+——+———–+——–+———+——+——-+———————–+</p>
<p>| 54 | root | localhost | sakila | Query   |    0 | init  | show full processlist |</p>
<p>+—-+——+———–+——–+———+——+——-+———————–+</p>
<p>1 row in set (0.00 sec)</p>
<h5 id="3、interactive-timeout"><a href="#3、interactive-timeout" class="headerlink" title="3、interactive_timeout"></a>3、interactive_timeout</h5><p>一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。</p>
<p>默认数值是28800，可调优为7200。</p>
<h4 id="2-、缓冲区变量"><a href="#2-、缓冲区变量" class="headerlink" title="2**、缓冲区变量**"></a><strong>2**</strong>、缓冲区变量**</h4><h5 id="1、全局缓冲："><a href="#1、全局缓冲：" class="headerlink" title="1、全局缓冲："></a>1、全局缓冲：</h5><h6 id="1、key-buffer-size"><a href="#1、key-buffer-size" class="headerlink" title="1、key_buffer_size"></a>1、key_buffer_size</h6><p>key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。</p>
<p>key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</p>
<p>举例如下：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg" alt="img"></p>
<p>key_buffer_size为512MB，我们再看一下key_buffer_size的使用情况：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg" alt="img"></p>
<p>一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：</p>
<p>key_cache_miss_rate ＝Key_reads / Key_read_requests * 100%，设置在1/1000左右较好</p>
<p>默认配置数值是8388600(8M)，主机有4GB内存，可以调优值268435456(256MB)。</p>
<h6 id="2、query-cache-size"><a href="#2、query-cache-size" class="headerlink" title="2、query_cache_size"></a>2、query_cache_size</h6><p>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。</p>
<p>与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。<br> query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</p>
<p>query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。</p>
<p>query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。</p>
<p>举例如下：</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg" alt="img"></p>
<p>查询缓存碎片率= Qcache_free_blocks / Qcache_total_blocks * 100%</p>
<p>如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。</p>
<p>查询缓存利用率= (query_cache_size – Qcache_free_memory) / query_cache_size * 100%</p>
<p>查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。</p>
<p>查询缓存命中率= (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%</p>
<p>示例服务器查询缓存碎片率＝20.46％，查询缓存利用率＝62.26％，查询缓存命中率＝1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。</p>
<h6 id="3、record-buffer-size"><a href="#3、record-buffer-size" class="headerlink" title="3、record_buffer_size"></a>3、record_buffer_size</h6><p>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</p>
<p>默认数值是131072(128K)，可改为16773120 (16M)</p>
<h6 id="4、read-rnd-buffer-size"><a href="#4、read-rnd-buffer-size" class="headerlink" title="4、read_rnd_buffer_size"></a>4、read_rnd_buffer_size</h6><p>随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</p>
<h6 id="5、sort-buffer-size"><a href="#5、sort-buffer-size" class="headerlink" title="5、sort_buffer_size"></a>5、sort_buffer_size</h6><p>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</p>
<p>默认数值是2097144(2M)，可改为16777208 (16M)。</p>
<h6 id="6、join-buffer-size"><a href="#6、join-buffer-size" class="headerlink" title="6、join_buffer_size"></a>6、join_buffer_size</h6><p>联合查询操作所能使用的缓冲区大小。</p>
<p>record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</p>
<h6 id="7、table-cache"><a href="#7、table-cache" class="headerlink" title="7、table_cache"></a>7、table_cache</h6><p>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</p>
<p>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</p>
<h6 id="8、max-heap-table-size"><a href="#8、max-heap-table-size" class="headerlink" title="8、max_heap_table_size"></a>8、max_heap_table_size</h6><p>用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#</p>
<p>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</p>
<h6 id="9、tmp-table-size"><a href="#9、tmp-table-size" class="headerlink" title="9、tmp_table_size"></a>9、tmp_table_size</h6><p>通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image039.jpg" alt="img"></p>
<p>每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：</p>
<p>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%，应该相当好了</p>
<p>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞</p>
<h6 id="10、thread-cache-size"><a href="#10、thread-cache-size" class="headerlink" title="10、thread_cache_size"></a>10、thread_cache_size</h6><p>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</p>
<p>通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</p>
<h6 id="11、thread-concurrency"><a href="#11、thread-concurrency" class="headerlink" title="11、thread_concurrency"></a>11、thread_concurrency</h6><p>推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为8</p>
<h6 id="12、wait-timeout"><a href="#12、wait-timeout" class="headerlink" title="12、wait_timeout"></a>12、wait_timeout</h6><p>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</p>
<h4 id="3、配置InnoDB的几个变量"><a href="#3、配置InnoDB的几个变量" class="headerlink" title="3、配置InnoDB的几个变量"></a>3、配置InnoDB的几个变量</h4><h5 id="1、innodb-buffer-pool-size"><a href="#1、innodb-buffer-pool-size" class="headerlink" title="1、innodb_buffer_pool_size"></a>1、innodb_buffer_pool_size</h5><p>对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</p>
<p>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</p>
<p>show status like ‘innodb%’;</p>
<h5 id="2、innodb-flush-log-at-trx-commit"><a href="#2、innodb-flush-log-at-trx-commit" class="headerlink" title="2、innodb_flush_log_at_trx_commit"></a>2、innodb_flush_log_at_trx_commit</h5><p>主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</p>
<p>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</p>
<p>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</p>
<h5 id="3、innodb-log-buffer-size"><a href="#3、innodb-log-buffer-size" class="headerlink" title="3、innodb_log_buffer_size"></a>3、innodb_log_buffer_size</h5><p>log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</p>
<h5 id="4、innodb-additional-mem-pool-size"><a href="#4、innodb-additional-mem-pool-size" class="headerlink" title="4、innodb_additional_mem_pool_size"></a>4、innodb_additional_mem_pool_size</h5><p>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</p>
<p>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</p>
<p>innodb_thread_concurrency=8</p>
<p>推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</p>
<h5 id="5、skip-name-resolve"><a href="#5、skip-name-resolve" class="headerlink" title="5、skip-name-resolve"></a>5、skip-name-resolve</h5><p># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，</p>
<p># 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</p>
<p>#skip-networking</p>
<p>back_log = 600</p>
<p># MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，</p>
<p># 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。</p>
<p># 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，</p>
<p># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</p>
<p># 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。</p>
<p># 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。</p>
<p>max_connections = 1000</p>
<p># MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</p>
<p>max_connect_errors = 6000</p>
<p># 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。</p>
<p>open_files_limit = 65535</p>
<p># MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，</p>
<p># 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。</p>
<p>table_open_cache = 128</p>
<p># MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64</p>
<p># 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；</p>
<p># 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上</p>
<p>max_allowed_packet = 4M</p>
<p># 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。</p>
<p># 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。</p>
<p>binlog_cache_size = 1M</p>
<p># 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K</p>
<p>max_heap_table_size = 8M</p>
<p># 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变</p>
<p>tmp_table_size = 16M</p>
<p># MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。</p>
<p># 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。</p>
<p># 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果</p>
<p>read_buffer_size = 2M</p>
<p># MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。</p>
<p># 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能</p>
<p>read_rnd_buffer_size = 8M</p>
<p># MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，</p>
<p># MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</p>
<p>sort_buffer_size = 8M</p>
<p># MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。</p>
<p># 如果不能，可以尝试增加sort_buffer_size变量的大小</p>
<p>join_buffer_size = 8M</p>
<p># 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享</p>
<p>thread_cache_size = 8</p>
<p># 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，</p>
<p># 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，</p>
<p># 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)</p>
<p># 根据物理内存设置规则如下：</p>
<p># 1G —&gt; 8</p>
<p># 2G —&gt; 16</p>
<p># 3G —&gt; 32</p>
<p># 大于3G —&gt; 64</p>
<p>query_cache_size = 8M</p>
<p>#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，</p>
<p># 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。</p>
<p># 通过检查状态值’Qcache_%’，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，</p>
<p># 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，</p>
<p># 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲</p>
<p>query_cache_limit = 2M</p>
<p>#指定单个查询能够使用的缓冲区大小，默认1M</p>
<p>key_buffer_size = 4M</p>
<p>#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，</p>
<p># 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，</p>
<p># 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，</p>
<p># 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得)。注意：该参数值设置的过大反而会是服务器整体效率降低</p>
<p>ft_min_word_len = 4</p>
<p># 分词词汇最小长度，默认4</p>
<p>transaction_isolation = REPEATABLE-READ</p>
<p># MySQL支持4种事务隔离级别，他们分别是：</p>
<p># READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</p>
<p># 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED</p>
<p>log_bin = mysql-bin</p>
<p>binlog_format = mixed</p>
<p>expire_logs_days = 30 #超过30天的binlog删除</p>
<p>log_error = /data/mysql/mysql-error.log #错误日志路径</p>
<p>slow_query_log = 1</p>
<p>long_query_time = 1 #慢查询时间 超过1秒则为慢查询</p>
<p>slow_query_log_file = /data/mysql/mysql-slow.log</p>
<p>performance_schema = 0</p>
<p>explicit_defaults_for_timestamp</p>
<p>#lower_case_table_names = 1 #不区分大小写</p>
<p>skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启</p>
<p>default-storage-engine = InnoDB #默认存储引擎</p>
<p>innodb_file_per_table = 1</p>
<p># InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间</p>
<p># 独立表空间优点：</p>
<p># 1．每个表都有自已独立的表空间。</p>
<p># 2．每个表的数据和索引都会存在自已的表空间中。</p>
<p># 3．可以实现单表在不同的数据库中移动。</p>
<p># 4．空间可以回收（除drop table操作处，表空不能自已回收）</p>
<p># 缺点：</p>
<p># 单表增加过大，如超过100G</p>
<p># 结论：</p>
<p># 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files</p>
<p>innodb_open_files = 500</p>
<p># 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300</p>
<p>innodb_buffer_pool_size = 64M</p>
<p># InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.</p>
<p># 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.</p>
<p># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</p>
<p># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</p>
<p># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</p>
<p># 所以不要设置的太高.</p>
<p>innodb_write_io_threads = 4</p>
<p>innodb_read_io_threads = 4</p>
<p># innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4</p>
<p># 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64</p>
<p>innodb_thread_concurrency = 0</p>
<p># 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量</p>
<p>innodb_purge_threads = 1</p>
<p># InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。</p>
<p># 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单</p>
<p># 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1</p>
<p>innodb_flush_log_at_trx_commit = 2</p>
<p># 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。</p>
<p># 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1</p>
<p># 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。</p>
<p># 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。</p>
<p># 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘</p>
<p># 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。</p>
<p># 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</p>
<p># 总结</p>
<p># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</p>
<p>innodb_log_buffer_size = 2M</p>
<p># 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间</p>
<p>innodb_log_file_size = 32M</p>
<p># 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间</p>
<p>innodb_log_files_in_group = 3</p>
<p># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</p>
<p>innodb_max_dirty_pages_pct = 90</p>
<p># innodb主线程刷新缓存池中的数据，使脏数据比例小于90%</p>
<p>innodb_lock_wait_timeout = 120</p>
<p># InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒</p>
<p>bulk_insert_buffer_size = 8M</p>
<p># 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。</p>
<p>myisam_sort_buffer_size = 8M</p>
<p># MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区</p>
<p>myisam_max_sort_file_size = 10G</p>
<p># 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出</p>
<p>myisam_repair_threads = 1</p>
<p># 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)</p>
<p>interactive_timeout = 28800</p>
<p># 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）</p>
<p>wait_timeout = 28800</p>
<p># 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，</p>
<p># 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）</p>
<p># MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，</p>
<p># 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，</p>
<p># 最终肯定会达到MySQL Server的连接上限数，这会报’too many connections’的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。</p>
<p># 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，</p>
<p># 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。</p>
<p>[mysqldump]</p>
<p>quick</p>
<p>max_allowed_packet = 16M #服务器发送和接受的最大包长度</p>
<p>[myisamchk]</p>
<p>key_buffer_size = 8M</p>
<p>sort_buffer_size = 8M</p>
<p>read_buffer = 4M</p>
<p>write_buffer = 4M</p>
<p>附录：</p>
<p>1、查看innodb的相关参数信息</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image041.jpg" alt="img"></p>
<p>2、查看innodb的相关参数状态</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image043.jpg" alt="img"></p>
<h1 id="五、MySQL的执行顺序"><a href="#五、MySQL的执行顺序" class="headerlink" title="五、MySQL的执行顺序"></a>五、MySQL的执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/1573127667288.png" alt="1573127667288"></p>
<p>下面我们来具体分析一下查询处理的每一个阶段</p>
<ol>
<li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</li>
<li><strong>JOIN</strong>： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li><strong>WHERE</strong>： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</li>
<li><strong>GROUP      BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li><strong>CUBE      | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</li>
</ol>
<h1 id="六、MySQL执行引擎介绍（了解）"><a href="#六、MySQL执行引擎介绍（了解）" class="headerlink" title="六、MySQL执行引擎介绍（了解）"></a>六、MySQL执行引擎介绍（了解）</h1><h2 id="1、MyISAM存储引擎"><a href="#1、MyISAM存储引擎" class="headerlink" title="1、MyISAM存储引擎"></a>1、MyISAM存储引擎</h2><p>不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</p>
<p>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</p>
<p>静态表：</p>
<p>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</p>
<p>动态表：</p>
<p>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</p>
<p>压缩表：</p>
<p>因为每个记录是被单独压缩的，所以只有非常小的访问开支</p>
<h2 id="2、InnoDB存储引擎"><a href="#2、InnoDB存储引擎" class="headerlink" title="2、InnoDB存储引擎"></a>2、InnoDB存储引擎</h2><p>该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。<br> InnoDB存储引擎的特点：支持自动增长列，支持外键约束</p>
<h2 id="3、MEMORY存储引擎"><a href="#3、MEMORY存储引擎" class="headerlink" title="3、MEMORY存储引擎"></a>3、MEMORY存储引擎</h2><p>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。<br> MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围</p>
<p>Hash索引优点： </p>
<p>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </p>
<p>Hash索引缺点： </p>
<p>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</p>
<p>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</p>
<h2 id="4、MERGE存储引擎"><a href="#4、MERGE存储引擎" class="headerlink" title="4、MERGE存储引擎"></a>4、MERGE存储引擎</h2><p>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
<h1 id="MySQL的执行顺序"><a href="#MySQL的执行顺序" class="headerlink" title="MySQL的执行顺序"></a>MySQL的执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<p><img src="file:///C:/Users/18439/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p>
<p>下面我们来具体分析一下查询处理的每一个阶段</p>
<ol>
<li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</li>
<li><strong>JOIN</strong>： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li><strong>WHERE</strong>： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</li>
<li><strong>GROUP      BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li><strong>CUBE      | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</li>
</ol>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-sql分类"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.sql分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql备份"><span class="nav-number">1.1.</span> <span class="nav-text">mysql备份</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#笛卡尔积"><span class="nav-number">1.1.1.</span> <span class="nav-text">笛卡尔积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNION-和-UNION-ALL"><span class="nav-number">1.1.2.</span> <span class="nav-text">UNION 和 UNION ALL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CASE-WHEN"><span class="nav-number">1.1.3.</span> <span class="nav-text">CASE WHEN</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MYSQL编码"><span class="nav-number">2.</span> <span class="nav-text">MYSQL编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元数据"><span class="nav-number">3.</span> <span class="nav-text">元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改表数据"><span class="nav-number">3.1.</span> <span class="nav-text">修改表数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串函数"><span class="nav-number">3.2.</span> <span class="nav-text">字符串函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MYSQL索引"><span class="nav-number">4.</span> <span class="nav-text">MYSQL索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引的优化"><span class="nav-number">4.1.</span> <span class="nav-text">索引的优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MYSQL事务"><span class="nav-number"></span> <span class="nav-text">MYSQL事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MYSQL优化"><span class="nav-number"></span> <span class="nav-text">MYSQL优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三种需要优化的sql"><span class="nav-number"></span> <span class="nav-text">三种需要优化的sql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#每个字段的说明："><span class="nav-number"></span> <span class="nav-text">每个字段的说明：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#max函数优化"><span class="nav-number">1.</span> <span class="nav-text">max函数优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT函数优化"><span class="nav-number">2.</span> <span class="nav-text">COUNT函数优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子查询最好把in优化成inner-join查询-但是join查询会产生重复数据-可以使用distinct去重-join的查询效率更高"><span class="nav-number">2.1.</span> <span class="nav-text">子查询最好把in优化成inner join查询 , 但是join查询会产生重复数据,可以使用distinct去重,join的查询效率更高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页"><span class="nav-number">2.2.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group分组优化"><span class="nav-number">2.3.</span> <span class="nav-text">group分组优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#limit查询优化"><span class="nav-number">2.4.</span> <span class="nav-text">limit查询优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、MYSQL数据库设计规范"><span class="nav-number"></span> <span class="nav-text">一、MYSQL数据库设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-数据库命名规范"><span class="nav-number"></span> <span class="nav-text">1、 数据库命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、-数据库表名命名规范"><span class="nav-number"></span> <span class="nav-text">2、 数据库表名命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、-数据库表字段名命名规范"><span class="nav-number"></span> <span class="nav-text">3、 数据库表字段名命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、-数据库表字段类型规范"><span class="nav-number"></span> <span class="nav-text">4、 数据库表字段类型规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、-数据库表索引规范"><span class="nav-number"></span> <span class="nav-text">5、 数据库表索引规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、-简单熟悉数据库范式"><span class="nav-number"></span> <span class="nav-text">6、 简单熟悉数据库范式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、MYSQL数据库设计原则"><span class="nav-number"></span> <span class="nav-text">一、MYSQL数据库设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、核心原则"><span class="nav-number"></span> <span class="nav-text">1、核心原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、字段类原则"><span class="nav-number"></span> <span class="nav-text">2、字段类原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、索引类原则"><span class="nav-number"></span> <span class="nav-text">3、索引类原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、sql类原则"><span class="nav-number"></span> <span class="nav-text">4、sql类原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库结构的优化"><span class="nav-number"></span> <span class="nav-text">数据库结构的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、选择合适的数据类型"><span class="nav-number"></span> <span class="nav-text">1、选择合适的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、数据类型选择"><span class="nav-number">1.</span> <span class="nav-text">1、数据类型选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、案例"><span class="nav-number">2.</span> <span class="nav-text">2、案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、数据库表的范式化优化"><span class="nav-number"></span> <span class="nav-text">2、数据库表的范式化优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、表范式化"><span class="nav-number">1.</span> <span class="nav-text">1、表范式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、反范式化"><span class="nav-number">2.</span> <span class="nav-text">2、反范式化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、数据库表的垂直拆分"><span class="nav-number"></span> <span class="nav-text">3、数据库表的垂直拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、垂直拆分定义"><span class="nav-number">1.</span> <span class="nav-text">1、垂直拆分定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、垂直拆分原则"><span class="nav-number">2.</span> <span class="nav-text">2、垂直拆分原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、数据库表的水平拆分"><span class="nav-number"></span> <span class="nav-text">4、数据库表的水平拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、为什么水平拆分"><span class="nav-number">1.</span> <span class="nav-text">1、为什么水平拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、水平不拆分原因"><span class="nav-number">2.</span> <span class="nav-text">2、水平不拆分原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、如何将数据平均分为N份"><span class="nav-number">3.</span> <span class="nav-text">3、如何将数据平均分为N份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、水平拆分面临的挑战"><span class="nav-number">4.</span> <span class="nav-text">4、水平拆分面临的挑战</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、数据库系统配置优化"><span class="nav-number"></span> <span class="nav-text">四、数据库系统配置优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、定义"><span class="nav-number"></span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、优化配置参数-操作系统"><span class="nav-number"></span> <span class="nav-text">2、优化配置参数-操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、操作系统的优化"><span class="nav-number">1.</span> <span class="nav-text">1、操作系统的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、打开文件数的限制"><span class="nav-number">2.</span> <span class="nav-text">2、打开文件数的限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、优化配置参数-MySQL配置文件优化"><span class="nav-number"></span> <span class="nav-text">3、优化配置参数- MySQL配置文件优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、MySQL配置文件修改"><span class="nav-number">1.</span> <span class="nav-text">1、MySQL配置文件修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、MySQL配置文件-常用参数说明"><span class="nav-number">2.</span> <span class="nav-text">2、MySQL配置文件-常用参数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、连接请求的变量"><span class="nav-number">2.1.</span> <span class="nav-text">1、连接请求的变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、max-connections"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、max_connections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、back-log"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、back_log</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、interactive-timeout"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、interactive_timeout</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-、缓冲区变量"><span class="nav-number">2.2.</span> <span class="nav-text">2**、缓冲区变量**</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、全局缓冲："><span class="nav-number">2.2.1.</span> <span class="nav-text">1、全局缓冲：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、key-buffer-size"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1、key_buffer_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、query-cache-size"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2、query_cache_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、record-buffer-size"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3、record_buffer_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、read-rnd-buffer-size"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">4、read_rnd_buffer_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5、sort-buffer-size"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">5、sort_buffer_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6、join-buffer-size"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">6、join_buffer_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7、table-cache"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">7、table_cache</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8、max-heap-table-size"><span class="nav-number">2.2.1.8.</span> <span class="nav-text">8、max_heap_table_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9、tmp-table-size"><span class="nav-number">2.2.1.9.</span> <span class="nav-text">9、tmp_table_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10、thread-cache-size"><span class="nav-number">2.2.1.10.</span> <span class="nav-text">10、thread_cache_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11、thread-concurrency"><span class="nav-number">2.2.1.11.</span> <span class="nav-text">11、thread_concurrency</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#12、wait-timeout"><span class="nav-number">2.2.1.12.</span> <span class="nav-text">12、wait_timeout</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、配置InnoDB的几个变量"><span class="nav-number">2.3.</span> <span class="nav-text">3、配置InnoDB的几个变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、innodb-buffer-pool-size"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、innodb_buffer_pool_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、innodb-flush-log-at-trx-commit"><span class="nav-number">2.3.2.</span> <span class="nav-text">2、innodb_flush_log_at_trx_commit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、innodb-log-buffer-size"><span class="nav-number">2.3.3.</span> <span class="nav-text">3、innodb_log_buffer_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、innodb-additional-mem-pool-size"><span class="nav-number">2.3.4.</span> <span class="nav-text">4、innodb_additional_mem_pool_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、skip-name-resolve"><span class="nav-number">2.3.5.</span> <span class="nav-text">5、skip-name-resolve</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、MySQL的执行顺序"><span class="nav-number"></span> <span class="nav-text">五、MySQL的执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、MySQL执行引擎介绍（了解）"><span class="nav-number"></span> <span class="nav-text">六、MySQL执行引擎介绍（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、MyISAM存储引擎"><span class="nav-number"></span> <span class="nav-text">1、MyISAM存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、InnoDB存储引擎"><span class="nav-number"></span> <span class="nav-text">2、InnoDB存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、MEMORY存储引擎"><span class="nav-number"></span> <span class="nav-text">3、MEMORY存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、MERGE存储引擎"><span class="nav-number"></span> <span class="nav-text">4、MERGE存储引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL的执行顺序"><span class="nav-number"></span> <span class="nav-text">MySQL的执行顺序</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kay</p>
  <div class="site-description" itemprop="description">If you have any request, please send it to my email(1843942434@qq.com).</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kay</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
